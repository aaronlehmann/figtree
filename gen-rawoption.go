// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package figtree

import "fmt"

type BoolOption struct {
	Source  string
	Defined bool
	Value   bool
}

func NewBoolOption(dflt bool) BoolOption {
	return BoolOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *BoolOption) IsDefined() bool {
	return o.Defined
}

func (o *BoolOption) SetSource(source string) {
	o.Source = source
}

func (o *BoolOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *BoolOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *BoolOption) SetValue(v interface{}) error {
	if val, ok := v.(bool); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *BoolOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o BoolOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o BoolOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type ByteOption struct {
	Source  string
	Defined bool
	Value   byte
}

func NewByteOption(dflt byte) ByteOption {
	return ByteOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *ByteOption) IsDefined() bool {
	return o.Defined
}

func (o *ByteOption) SetSource(source string) {
	o.Source = source
}

func (o *ByteOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *ByteOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *ByteOption) SetValue(v interface{}) error {
	if val, ok := v.(byte); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *ByteOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o ByteOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o ByteOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Complex128Option struct {
	Source  string
	Defined bool
	Value   complex128
}

func NewComplex128Option(dflt complex128) Complex128Option {
	return Complex128Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Complex128Option) IsDefined() bool {
	return o.Defined
}

func (o *Complex128Option) SetSource(source string) {
	o.Source = source
}

func (o *Complex128Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Complex128Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Complex128Option) SetValue(v interface{}) error {
	if val, ok := v.(complex128); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Complex128Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Complex128Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Complex128Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Complex64Option struct {
	Source  string
	Defined bool
	Value   complex64
}

func NewComplex64Option(dflt complex64) Complex64Option {
	return Complex64Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Complex64Option) IsDefined() bool {
	return o.Defined
}

func (o *Complex64Option) SetSource(source string) {
	o.Source = source
}

func (o *Complex64Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Complex64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Complex64Option) SetValue(v interface{}) error {
	if val, ok := v.(complex64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Complex64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Complex64Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Complex64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type ErrorOption struct {
	Source  string
	Defined bool
	Value   error
}

func NewErrorOption(dflt error) ErrorOption {
	return ErrorOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *ErrorOption) IsDefined() bool {
	return o.Defined
}

func (o *ErrorOption) SetSource(source string) {
	o.Source = source
}

func (o *ErrorOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *ErrorOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *ErrorOption) SetValue(v interface{}) error {
	if val, ok := v.(error); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *ErrorOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o ErrorOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o ErrorOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Float32Option struct {
	Source  string
	Defined bool
	Value   float32
}

func NewFloat32Option(dflt float32) Float32Option {
	return Float32Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Float32Option) IsDefined() bool {
	return o.Defined
}

func (o *Float32Option) SetSource(source string) {
	o.Source = source
}

func (o *Float32Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Float32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Float32Option) SetValue(v interface{}) error {
	if val, ok := v.(float32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Float32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Float32Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Float32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Float64Option struct {
	Source  string
	Defined bool
	Value   float64
}

func NewFloat64Option(dflt float64) Float64Option {
	return Float64Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Float64Option) IsDefined() bool {
	return o.Defined
}

func (o *Float64Option) SetSource(source string) {
	o.Source = source
}

func (o *Float64Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Float64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Float64Option) SetValue(v interface{}) error {
	if val, ok := v.(float64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Float64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Float64Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Float64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type IntOption struct {
	Source  string
	Defined bool
	Value   int
}

func NewIntOption(dflt int) IntOption {
	return IntOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *IntOption) IsDefined() bool {
	return o.Defined
}

func (o *IntOption) SetSource(source string) {
	o.Source = source
}

func (o *IntOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *IntOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *IntOption) SetValue(v interface{}) error {
	if val, ok := v.(int); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *IntOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o IntOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o IntOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Int16Option struct {
	Source  string
	Defined bool
	Value   int16
}

func NewInt16Option(dflt int16) Int16Option {
	return Int16Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Int16Option) IsDefined() bool {
	return o.Defined
}

func (o *Int16Option) SetSource(source string) {
	o.Source = source
}

func (o *Int16Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Int16Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Int16Option) SetValue(v interface{}) error {
	if val, ok := v.(int16); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Int16Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Int16Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Int16Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Int32Option struct {
	Source  string
	Defined bool
	Value   int32
}

func NewInt32Option(dflt int32) Int32Option {
	return Int32Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Int32Option) IsDefined() bool {
	return o.Defined
}

func (o *Int32Option) SetSource(source string) {
	o.Source = source
}

func (o *Int32Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Int32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Int32Option) SetValue(v interface{}) error {
	if val, ok := v.(int32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Int32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Int32Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Int32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Int64Option struct {
	Source  string
	Defined bool
	Value   int64
}

func NewInt64Option(dflt int64) Int64Option {
	return Int64Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Int64Option) IsDefined() bool {
	return o.Defined
}

func (o *Int64Option) SetSource(source string) {
	o.Source = source
}

func (o *Int64Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Int64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Int64Option) SetValue(v interface{}) error {
	if val, ok := v.(int64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Int64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Int64Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Int64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Int8Option struct {
	Source  string
	Defined bool
	Value   int8
}

func NewInt8Option(dflt int8) Int8Option {
	return Int8Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Int8Option) IsDefined() bool {
	return o.Defined
}

func (o *Int8Option) SetSource(source string) {
	o.Source = source
}

func (o *Int8Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Int8Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Int8Option) SetValue(v interface{}) error {
	if val, ok := v.(int8); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Int8Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Int8Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Int8Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type RuneOption struct {
	Source  string
	Defined bool
	Value   rune
}

func NewRuneOption(dflt rune) RuneOption {
	return RuneOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *RuneOption) IsDefined() bool {
	return o.Defined
}

func (o *RuneOption) SetSource(source string) {
	o.Source = source
}

func (o *RuneOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *RuneOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *RuneOption) SetValue(v interface{}) error {
	if val, ok := v.(rune); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *RuneOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o RuneOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o RuneOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type StringOption struct {
	Source  string
	Defined bool
	Value   string
}

func NewStringOption(dflt string) StringOption {
	return StringOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *StringOption) IsDefined() bool {
	return o.Defined
}

func (o *StringOption) SetSource(source string) {
	o.Source = source
}

func (o *StringOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *StringOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *StringOption) SetValue(v interface{}) error {
	if val, ok := v.(string); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *StringOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o StringOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o StringOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type UintOption struct {
	Source  string
	Defined bool
	Value   uint
}

func NewUintOption(dflt uint) UintOption {
	return UintOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *UintOption) IsDefined() bool {
	return o.Defined
}

func (o *UintOption) SetSource(source string) {
	o.Source = source
}

func (o *UintOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *UintOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *UintOption) SetValue(v interface{}) error {
	if val, ok := v.(uint); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *UintOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o UintOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o UintOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Uint16Option struct {
	Source  string
	Defined bool
	Value   uint16
}

func NewUint16Option(dflt uint16) Uint16Option {
	return Uint16Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Uint16Option) IsDefined() bool {
	return o.Defined
}

func (o *Uint16Option) SetSource(source string) {
	o.Source = source
}

func (o *Uint16Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Uint16Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Uint16Option) SetValue(v interface{}) error {
	if val, ok := v.(uint16); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Uint16Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Uint16Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Uint16Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Uint32Option struct {
	Source  string
	Defined bool
	Value   uint32
}

func NewUint32Option(dflt uint32) Uint32Option {
	return Uint32Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Uint32Option) IsDefined() bool {
	return o.Defined
}

func (o *Uint32Option) SetSource(source string) {
	o.Source = source
}

func (o *Uint32Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Uint32Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Uint32Option) SetValue(v interface{}) error {
	if val, ok := v.(uint32); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Uint32Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Uint32Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Uint32Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Uint64Option struct {
	Source  string
	Defined bool
	Value   uint64
}

func NewUint64Option(dflt uint64) Uint64Option {
	return Uint64Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Uint64Option) IsDefined() bool {
	return o.Defined
}

func (o *Uint64Option) SetSource(source string) {
	o.Source = source
}

func (o *Uint64Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Uint64Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Uint64Option) SetValue(v interface{}) error {
	if val, ok := v.(uint64); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Uint64Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Uint64Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Uint64Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type Uint8Option struct {
	Source  string
	Defined bool
	Value   uint8
}

func NewUint8Option(dflt uint8) Uint8Option {
	return Uint8Option{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *Uint8Option) IsDefined() bool {
	return o.Defined
}

func (o *Uint8Option) SetSource(source string) {
	o.Source = source
}

func (o *Uint8Option) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *Uint8Option) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *Uint8Option) SetValue(v interface{}) error {
	if val, ok := v.(uint8); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *Uint8Option) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o Uint8Option) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o Uint8Option) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}

type UintptrOption struct {
	Source  string
	Defined bool
	Value   uintptr
}

func NewUintptrOption(dflt uintptr) UintptrOption {
	return UintptrOption{
		Source:  "default",
		Defined: false,
		Value:   dflt,
	}
}

func (o *UintptrOption) IsDefined() bool {
	return o.Defined
}

func (o *UintptrOption) SetSource(source string) {
	o.Source = source
}

func (o *UintptrOption) GetValue() interface{} {
	return o.Value
}

// This is useful with kingpin option parser
func (o *UintptrOption) Set(s string) error {
	err := convertString(s, &o.Value)
	if err != nil {
		return err
	}
	o.Source = "override"
	o.Defined = true
	return nil
}

func (o *UintptrOption) SetValue(v interface{}) error {
	if val, ok := v.(uintptr); ok {
		o.Value = val
		o.Defined = true
		return nil
	}
	return fmt.Errorf("Got %T expected %T type: %v", v, o.Value, v)
}

func (o *UintptrOption) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if err := unmarshal(&o.Value); err == nil {
		o.Defined = true
	} else {
		return err
	}

	return nil
}

func (o UintptrOption) MarshalYAML() (interface{}, error) {
	return o.Value, nil
}

func (o UintptrOption) String() string {
	if StringifyValue {
		return fmt.Sprintf("%v", o.Value)
	}
	return fmt.Sprintf("{Source:%s Defined:%t Value:%v}", o.Source, o.Defined, o.Value)
}
